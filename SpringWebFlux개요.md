# Spring WebFlux란?
- Spring 5부터 지원하는 리액티브 웹 프레임워크
- 비동기 Non-Blocking I/O 방식으로 적은 수의 쓰레드를 사용함
- Reactive Streams의 구현체 중에 하나인 Reactor에 의존해 비동기 로직을 구성하고 리액티브 스트림을 제공함
- Reactor 기반이지만 RxJava등 다른 리액티브 확장 라이브러리를 쉽게 적용할 수 있다
- Spring WebFlux 자체의 학습 비용보다 Reactor의 학습 비용이 더 많이 든다.
- MVC와 Webflux기술스텍 차이(https://spring.io/reactive)
  - 서블릿 컨테이너 대신 (Netty 비동기 논블로킹을 지원하는 서버엔진을 사용함, 서블릿3.1이상의 컨테이너도 사용가능)
  - Tomcat, Jetty, Undertow등 mvc와 같은 엔진 가능
  - 비동기 논블로킹을 위해 event loop라는 concurrency model을 사용함

# Spring WebFlux의 Non-Blocking 프로세스
- 클라이언트 측에서 요청 핸들러에 리퀘스트를 보냄
- 그럼 해당 핸들러는 이벤트 루프에 요청 이벤트를 푸시함
- 해당 이벤트 루프는 푸시된 요청 이벤트에 콜백을 등록하고 -> 시간이 오래걸리는 작업(네트워크,DB,연산 작업 등)
- 작업 완료 이벤트 푸시
- 콜백 호출
- 요청 핸들러가 클라이언트에 날림

- Servlet api에서는 하나의 요청당 하나의 쓰레드가 매핑이 되지만, Event loop를 사용하는데는 하나의 쓰레드로 대량의 클라이언트 요청을 처리함
- 일반적으로 cpu코어만큼의 갯수가 있으면 클라이언트가 보내는 요청을 처리할 수 있음

# WebFlux를 사용하기 적합한 시스템
- Blocking I/O 방식으로 처리하는데 한게가 있는 대량의 요청 트래픽이 발생하는 시스템
  - 언제나 정답은 아님, 시스템 요청 트래픽이 충분히 감당가능하면, Servlet기반의 블로킹으로 충분히 감당가능함
- 마이크로 서비스 기반 시스템(많은 수의 IO가 일어남)
- 스트리밍 시스템 또는 실시간 시스템(끊임없이 들어오는 무한 데이터 스트림을 받아서 효율적으로 처리함)
- 네트워크 접속이 느린 클라이언트의 요청 처리
  - MVC에서는 클라이언트수가 늘어나면 정상적으로 접속하기 힘든데, webflux는 쓰레드를 차단하지 않기때문에 계속해서 다른 요청들을 연결하기 때문에 이런 특징을 사용해서 처리하기 적합함
