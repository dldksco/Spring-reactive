## Blocing I/O
- 작업 쓰레드가 종료될때까지 요청을 한 쓰레드는 차단됨
- 이러한 단점을 보완할려면 멀티 쓰레딩 기법을 통해 추가 쓰레드를 할당 할 수 있음
- CPU 대비 많은 수의 쓰레드를 사용하는 애플리케이션은 비효율적임
  - 컨텍스트 스위칭으로 인한 쓰레드 전환 비용 발생

  - 메모리 사용에 있어서 오버 헤드 발생(쓰레드가 증가함에ㄷ 따라 자연스레 올라감)
  - 쓰레드 풀에서의 응답 지연 문제 발생(서블릿 기반 애플리케이션은 쓰레드를 사용하고 사용이 끝난 쓰레드를 다시 풀에 반납하는데 그 과정에서 응답이 지연됨)

  - 컨텍스트 스위칭 비용 발생
    - 프로세스
      - 프로세스 p1이 실행되고 그 중지되는 시점에 PCB(Process Control Block)에 해당 프로세스 상태 저장
      - 그때 프로세스 p2는 유휴 시간(Idle Time)을 가지고
      - 유휴 시간이 끝날 때쯤 PCB에서 프로세스 상태를 reload함
      - 다시 p1 작업 반복
      - 문제가 뭐냐 p1의 실행시점과 p2의 idle time이 끝나는 시간이 일치하지 않음
      - pcb에 저장하고 pcb에서 로드하는데 추가 시간이 들어가기때문에 실행 시점과 idle time이 딱 맞지 않음
      - pcb에 저장하고 pcb에서 로드하는 시간동안 cpu는 대기하며, 일을 하지 못함.
      - 즉 컨텍스트 스위칭이 잦을수록 cpu 전체 대기 시간이 길어지므로 성능이 저하됨
    - 쓰레드
      - 프로세스랑 비슷하지만 여러 개의 쓰레드는 하나의 프로세스 정보를 공유하고 있어서 저장되는 상태값과 다시 로드하는 상태값이 프로세스보다 더 적음
  - 메모리 사용에 있는 오버헤드
    - default stack size for the 64-bit JVM = 1024KB
    - 64000명 동시 접속 시, 64GB의 메모리가 추가로 필요함
  - 쓰레드 풀에서의 응답 지연 문제
    - 쓰레드 풀에 유휴 쓰레드가 없다면 이미 사용된 쓰레드를 반납할 때 까지 응답 지연시간이 길어짐
    - 하지만 반납된 쓰레드가 사용 가능하도록 전환되는 과정에서도 응답 지연 발생

## Non-Blocking I/O
- 작업 쓰레드의 종료와 상관없이 요청 쓰레드는 차단되지 않음
- 적은 수의 쓰레드를 사용하기 때문에 쓰레드 전환 비용이 적게 발생함
- 따라서 CPU 대기 시간 및 사용량에 있어서는 효율적임
- 하지만 CPU를 많이 사용하는 작업이 포함 되어 있으면 성능 향상에 악영향을 줌(사용 가능한 쓰레드가 있다면 추가적으로 할당하거나, 일반적으로 외부 시스템을 의존함)
  - 이 작업이 대부분의 CPU를 점유해버리기 때문에 다른 I/O 작업이 CPU를 얻지 못하고 대기상태에 머무르게 되버릴 수 있음
- 사용자 요청부터 응답 까지의 과정에 Blocing I/O 요소가 포함되면 Non-Blocking 이점을 발휘하기 힘듬